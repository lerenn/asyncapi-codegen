// Code generated by dagger. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"

	"dagger/asyncapi-codegen-ci/internal/dagger"
	"dagger/asyncapi-codegen-ci/internal/telemetry"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
	"go.opentelemetry.io/otel/trace"
)

var dag = dagger.Connect()

func Tracer() trace.Tracer {
	return otel.Tracer("dagger.io/sdk.go")
}

// used for local MarshalJSON implementations
var marshalCtx = context.Background()

// called by main()
func setMarshalContext(ctx context.Context) {
	marshalCtx = ctx
	dagger.SetMarshalContext(ctx)
}

type DaggerObject = dagger.DaggerObject

type ExecError = dagger.ExecError

// ptr returns a pointer to the given value.
func ptr[T any](v T) *T {
	return &v
}

// convertSlice converts a slice of one type to a slice of another type using a
// converter function
func convertSlice[I any, O any](in []I, f func(I) O) []O {
	out := make([]O, len(in))
	for i, v := range in {
		out[i] = f(v)
	}
	return out
}

func (r AsyncapiCodegenCi) MarshalJSON() ([]byte, error) {
	var concrete struct{}
	return json.Marshal(&concrete)
}

func (r *AsyncapiCodegenCi) UnmarshalJSON(bs []byte) error {
	var concrete struct{}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	return nil
}

func main() {
	ctx := context.Background()

	// Direct slog to the new stderr. This is only for dev time debugging, and
	// runtime errors/warnings.
	slog.SetDefault(slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: slog.LevelWarn,
	})))

	if err := dispatch(ctx); err != nil {
		fmt.Println(err.Error())
		os.Exit(2)
	}
}

func dispatch(ctx context.Context) error {
	ctx = telemetry.InitEmbedded(ctx, resource.NewWithAttributes(
		semconv.SchemaURL,
		semconv.ServiceNameKey.String("dagger-go-sdk"),
		// TODO version?
	))
	defer telemetry.Close()

	// A lot of the "work" actually happens when we're marshalling the return
	// value, which entails getting object IDs, which happens in MarshalJSON,
	// which has no ctx argument, so we use this lovely global variable.
	setMarshalContext(ctx)

	fnCall := dag.CurrentFunctionCall()
	parentName, err := fnCall.ParentName(ctx)
	if err != nil {
		return fmt.Errorf("get parent name: %w", err)
	}
	fnName, err := fnCall.Name(ctx)
	if err != nil {
		return fmt.Errorf("get fn name: %w", err)
	}
	parentJson, err := fnCall.Parent(ctx)
	if err != nil {
		return fmt.Errorf("get fn parent: %w", err)
	}
	fnArgs, err := fnCall.InputArgs(ctx)
	if err != nil {
		return fmt.Errorf("get fn args: %w", err)
	}

	inputArgs := map[string][]byte{}
	for _, fnArg := range fnArgs {
		argName, err := fnArg.Name(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg name: %w", err)
		}
		argValue, err := fnArg.Value(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg value: %w", err)
		}
		inputArgs[argName] = []byte(argValue)
	}

	result, err := invoke(ctx, []byte(parentJson), parentName, fnName, inputArgs)
	if err != nil {
		return fmt.Errorf("invoke: %w", err)
	}
	resultBytes, err := json.Marshal(result)
	if err != nil {
		return fmt.Errorf("marshal: %w", err)
	}
	if err = fnCall.ReturnValue(ctx, dagger.JSON(resultBytes)); err != nil {
		return fmt.Errorf("store return value: %w", err)
	}
	return nil
}
func invoke(ctx context.Context, parentJSON []byte, parentName string, fnName string, inputArgs map[string][]byte) (_ any, err error) {
	_ = inputArgs
	switch parentName {
	case "AsyncapiCodegenCi":
		switch fnName {
		case "Check":
			var parent AsyncapiCodegenCi
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var srcDir *dagger.Directory
			if inputArgs["srcDir"] != nil {
				err = json.Unmarshal([]byte(inputArgs["srcDir"]), &srcDir)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg srcDir", err))
				}
			}
			return (*AsyncapiCodegenCi).Check(&parent, ctx, srcDir)
		case "CheckGeneration":
			var parent AsyncapiCodegenCi
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var srcDir *dagger.Directory
			if inputArgs["srcDir"] != nil {
				err = json.Unmarshal([]byte(inputArgs["srcDir"]), &srcDir)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg srcDir", err))
				}
			}
			return (*AsyncapiCodegenCi).CheckGeneration(&parent, ctx, srcDir)
		case "Lint":
			var parent AsyncapiCodegenCi
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var srcDir *dagger.Directory
			if inputArgs["srcDir"] != nil {
				err = json.Unmarshal([]byte(inputArgs["srcDir"]), &srcDir)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg srcDir", err))
				}
			}
			return (*AsyncapiCodegenCi).Lint(&parent, ctx, srcDir)
		case "Examples":
			var parent AsyncapiCodegenCi
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var srcDir *dagger.Directory
			if inputArgs["srcDir"] != nil {
				err = json.Unmarshal([]byte(inputArgs["srcDir"]), &srcDir)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg srcDir", err))
				}
			}
			return (*AsyncapiCodegenCi).Examples(&parent, ctx, srcDir)
		case "Tests":
			var parent AsyncapiCodegenCi
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var srcDir *dagger.Directory
			if inputArgs["srcDir"] != nil {
				err = json.Unmarshal([]byte(inputArgs["srcDir"]), &srcDir)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg srcDir", err))
				}
			}
			return (*AsyncapiCodegenCi).Tests(&parent, ctx, srcDir)
		case "Publish":
			var parent AsyncapiCodegenCi
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var srcDir *dagger.Directory
			if inputArgs["srcDir"] != nil {
				err = json.Unmarshal([]byte(inputArgs["srcDir"]), &srcDir)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg srcDir", err))
				}
			}
			var sshDir *dagger.Directory
			if inputArgs["sshDir"] != nil {
				err = json.Unmarshal([]byte(inputArgs["sshDir"]), &sshDir)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg sshDir", err))
				}
			}
			return nil, (*AsyncapiCodegenCi).Publish(&parent, ctx, srcDir, sshDir)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "":
		return dag.Module().
			WithDescription("A generated module for AsyncapiCodegenCi functions\n\nThis module has been generated via dagger init and serves as a reference to\nbasic module structure as you get started with Dagger.\n\nTwo functions have been pre-created. You can modify, delete, or add to them,\nas needed. They demonstrate usage of arguments and return types using simple\necho and grep commands. The functions can be called from the dagger CLI or\nfrom one of the SDKs.\n\nThe first line in this comment block is a short description line and the\nrest is a long description with more detail on the module's purpose or usage,\nif appropriate. All modules should have a short description.\n").
			WithObject(
				dag.TypeDef().WithObject("AsyncapiCodegenCi", dagger.TypeDefWithObjectOpts{Description: "AsyncapiCodegenCi is the Dagger CI module for AsyncAPI Codegen."}).
					WithFunction(
						dag.Function("Check",
							dag.TypeDef().WithKind(dagger.StringKind)).
							WithDescription("Execute all check operations (generate, lint, examples, and tests)").
							WithArg("srcDir", dag.TypeDef().WithObject("Directory"))).
					WithFunction(
						dag.Function("CheckGeneration",
							dag.TypeDef().WithKind(dagger.StringKind)).
							WithDescription("CheckGeneration generate files from Golang generate command on AsyncAPI-Codegen\nsource code and check that there is no change.").
							WithArg("srcDir", dag.TypeDef().WithObject("Directory"))).
					WithFunction(
						dag.Function("Lint",
							dag.TypeDef().WithKind(dagger.StringKind)).
							WithDescription("Lint AsyncAPI-Codegen source code.").
							WithArg("srcDir", dag.TypeDef().WithObject("Directory"))).
					WithFunction(
						dag.Function("Examples",
							dag.TypeDef().WithKind(dagger.StringKind)).
							WithDescription("Run AsyncAPI-Codegen examples.").
							WithArg("srcDir", dag.TypeDef().WithObject("Directory"))).
					WithFunction(
						dag.Function("Tests",
							dag.TypeDef().WithKind(dagger.StringKind)).
							WithDescription("Run tests from AsyncAPICodegen").
							WithArg("srcDir", dag.TypeDef().WithObject("Directory"))).
					WithFunction(
						dag.Function("Publish",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("Publish tag on git repository and docker image(s) on Docker Hub\nNote: if this is not 'main' branch, then it will just push docker image with\ngit tag.").
							WithArg("srcDir", dag.TypeDef().WithObject("Directory")).
							WithArg("sshDir", dag.TypeDef().WithObject("Directory")))), nil
	default:
		return nil, fmt.Errorf("unknown object %s", parentName)
	}
}
