// NATSController is the NATS implementation for asyncapi-codegen
type NATSController struct {
    connection  *nats.Conn
    logger      Logger
    queueName   string
}

// NewNATSController creates a new NATSController that fulfill the BrokerLinker interface
func NewNATSController(connection *nats.Conn) *NATSController {
    return &NATSController{
        connection: connection,
        queueName:  "asyncapi",
    }
}

// SetQueueName sets a custom queue name for channel subscription
//
// It can be used for multiple applications listening one the same channel but
// wants to listen on different queues.
func (c *NATSController) SetQueueName(name string) {
    c.queueName = name
}

// SetLogger set a custom logger that will log operations on broker controller
func (c *NATSController) SetLogger(logger Logger) {
    c.logger = logger
}

// Publish a message to the broker
func (c *NATSController) Publish(channel string, um UniversalMessage) error {
	msg := nats.NewMsg(channel)

    // Set message content
	msg.Data = um.Payload
	if um.CorrelationID != nil {
		msg.Header.Add(CorrelationIDField, *um.CorrelationID)
	}

    // Publish message
	if err := c.connection.PublishMsg(msg); err != nil {
		return err
	}

    // Flush the queue
	return c.connection.Flush()
}

// Subscribe to messages from the broker
func (c *NATSController) Subscribe(channel string) (msgs chan UniversalMessage, stop chan interface{}, err error) {
    // Subscribe to channel
    natsMsgs := make(chan *nats.Msg, 64)
    sub, err := c.connection.QueueSubscribeSyncWithChan(channel, c.queueName, natsMsgs)
    if err != nil {
        return nil, nil, err
    }

    // Handle events
    msgs = make(chan UniversalMessage, 64)
    stop = make(chan interface{}, 1)
    go func() {
        for {
            select {
            // Handle new message
            case msg := <-natsMsgs:
                var correlationID *string

                // Add correlation ID if not empty
                str := msg.Header.Get(CorrelationIDField)
                if str != "" {
                    correlationID = &str
                }

                // Create message
                msgs <- UniversalMessage{
                    Payload: msg.Data,
                    CorrelationID: correlationID,
                }
            // Handle closure request from function caller
            case _ = <-stop:
                if err := sub.Unsubscribe(); err != nil && !errors.Is(err, nats.ErrConnectionClosed) && c.logger != nil {
                    c.logger.Error(err.Error(), LogInfo{"module", "asyncapi"}, LogInfo{"controller", "nats"})
                }

                if err := sub.Drain(); err != nil && !errors.Is(err, nats.ErrConnectionClosed) && c.logger != nil {
                    c.logger.Error(err.Error(), LogInfo{"module", "asyncapi"}, LogInfo{"controller", "nats"})
                }

                close(msgs)
            }
        }
    } ()


    return msgs, stop, nil
}
