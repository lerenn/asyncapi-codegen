// AppController is the structure that provides publishing capabilities to the
// developer and and connect the broker with the app
type AppController struct {
    brokerController BrokerController
    stopSubscribers map[string]chan interface{}
}

// NewAppController links the application to the broker
func NewAppController(bs BrokerController) (*AppController, error) {
    if bs == nil {
        return nil, ErrNilBrokerController
    }

    return &AppController{
        brokerController: bs,
        stopSubscribers: make(map[string]chan interface{}),
    }, nil
}

// Close will clean up any existing resources on the controller
func (ac *AppController) Close() {
{{if .PublishCount -}}
    ac.UnsubscribeAll()
{{else -}}
    // Nothing to do
{{- end}}
}

{{if .PublishCount -}}
// SubscribeAll will subscribe to channels on which the app is expecting messages
func (ac *AppController) SubscribeAll(as AppSubscriber) error {
    if as == nil {
        return ErrNilAppController
    }

    {{range  $key, $value := .Specification.Channels -}}{{- if $value.Publish -}}
    if err := ac.Subscribe{{namify $key}}(as.{{namify $key}}); err != nil {
        return err
    }
    {{end -}}{{- end}}

    return nil
}

// UnsubscribeAll will unsubscribe all remaining subscribed channels
func (ac *AppController) UnsubscribeAll() {
    {{range  $key, $value := .Specification.Channels -}}{{- if $value.Publish -}}
    ac.Unsubscribe{{namify $key}}()
    {{end -}}{{- end -}}
}
{{- end}}

{{range  $key, $value := .Specification.Channels -}}
{{- if $value.Publish -}}
// Subscribe{{namify $key}} will subscribe to new messages from '{{$key}}' channel
func (ac *AppController) Subscribe{{namify $key}}(fn func (msg {{channelToMessageTypeName $value}})) error {
    // TODO: check if there is already a subscription

    // Subscribe to broker channel
    msgs, stop, err := ac.brokerController.Subscribe("{{$key}}")
    if err != nil {
        return err
    }

    // Asynchronously listen to new messages and pass them to app subscriber
    go func() {
        for um, open := <-msgs; open; um, open = <-msgs{
            msg, err := new{{channelToMessageTypeName $value}}FromUniversalMessage(um)
            if err != nil {
                log.Printf("an error happened when receiving an event: %s (msg: %+v)\n", err, msg) // TODO: add proper error handling
                continue
            }

            fn(msg)
        }
    } ()

    // Add the stop channel to the inside map
    ac.stopSubscribers["{{$key}}"] = stop

    return nil
}

// Unsubscribe{{namify $key}} will unsubscribe messages from '{{$key}}' channel
func (ac *AppController) Unsubscribe{{namify $key}}() {
    stopChan, exists := ac.stopSubscribers["{{$key}}"]
    if !exists {
        return
    }

    stopChan <- true
    delete(ac.stopSubscribers, "{{$key}}") 
}
{{- end -}}
{{- end}}

{{- range  $key, $value := .Specification.Channels}}
{{if $value.Subscribe}}
// Publish{{namify $key}} will publish messages to '{{$key}}' channel
func (ac *AppController) Publish{{namify $key}}(msg {{channelToMessageTypeName $value}}) error {
    // TODO: check that 'ac' is not nil

    // Convert to UniversalMessage
    um, err := msg.toUniversalMessage()
    if err != nil  {
        return err
    }

    // Publish on event broker
    return ac.brokerController.Publish("{{$key}}", um)
}
{{end}}
{{end}}

// Listen will let the controller handle subscriptions and will be interrupted
// only when an struct is sent on the interrupt channel
func (ac *AppController) Listen(irq chan interface{}){
	<-irq
}
