// ClientController is the structure that provides publishing capabilities to the
// developer and and connect the broker with the client
type ClientController struct {
    brokerController BrokerController
    stopSubscribers map[string]chan interface{}
}

// NewClientController links the client to the broker
func NewClientController(bs BrokerController) (*ClientController, error) {
    if bs == nil {
        return nil, ErrNilBrokerController
    }

    return &ClientController{
        brokerController: bs,
        stopSubscribers: make(map[string]chan interface{}),
    }, nil
}

// Close will clean up any existing resources on the controller
func (cc *ClientController) Close() {
{{if .SubscribeCount -}}
    cc.UnsubscribeAll()
{{else -}}
    // Nothing to do
{{- end}}
}

{{if .SubscribeCount -}}
// SubscribeAll will subscribe to channels on which the client is expecting messages
func (cc *ClientController) SubscribeAll(cs ClientSubscriber) error {
    if cs == nil {
        return ErrNilClientController
    }

    {{range  $key, $value := .Specification.Channels -}}{{- if $value.Subscribe -}}
    if err := cc.Subscribe{{namify $key}}(cs.{{namify $key}}); err != nil {
        return err
    }
    {{end -}}{{- end}}

    return nil
}

// UnsubscribeAll will unsubscribe all remaining subscribed channels
func (cc *ClientController) UnsubscribeAll() {
    {{range  $key, $value := .Specification.Channels -}}{{- if $value.Subscribe -}}
    cc.Unsubscribe{{namify $key}}()
    {{end -}}{{- end -}}
}
{{- end}}

{{range  $key, $value := .Specification.Channels -}}
{{- if $value.Subscribe}}
// Subscribe{{namify $key}} will subscribe to new messages from '{{$key}}' channel
func (cc *ClientController) Subscribe{{namify $key}}(fn func (msg {{channelToMessageTypeName $value}})) error {
    // Check if there is already a subscription
    _, exists := cc.stopSubscribers["{{$key}}"]
    if exists {
        return fmt.Errorf("%w: {{$key}} channel is already subscribed", ErrAlreadySubscribedChannel)
    }

    // Subscribe to broker channel
    msgs, stop, err := cc.brokerController.Subscribe("{{$key}}")
    if err != nil {
        return err
    }

    // Asynchronously listen to new messages and pass them to client subscriber
    go func() {
        for um, open := <-msgs; open; um, open = <-msgs{
            msg, err := new{{channelToMessageTypeName $value}}FromUniversalMessage(um)
            if err != nil {
                log.Printf("an error happened when receiving an event: %s (msg: %+v)\n", err, msg) // TODO: add proper error handling
                continue
            }

            fn(msg)
        }
    } ()

    // Add the stop channel to the inside map
    cc.stopSubscribers["{{$key}}"] = stop

    return nil
}

// Unsubscribe{{namify $key}} will unsubscribe messages from '{{$key}}' channel
func (cc *ClientController) Unsubscribe{{namify $key}}() {
    stopChan, exists := cc.stopSubscribers["{{$key}}"]
    if !exists {
        return
    }

    stopChan <- true
    delete(cc.stopSubscribers, "{{$key}}") 
}
{{- end -}}
{{- end}}

{{- range  $key, $value := .Specification.Channels}}
{{if $value.Publish}}
// Publish{{namify $key}} will publish messages to '{{$key}}' channel
func (cc *ClientController) Publish{{namify $key}}(msg {{channelToMessageTypeName $value}}) error {
    // TODO: check that 'cc' is not nil

    // Convert to UniversalMessage
    um, err := msg.toUniversalMessage()
    if err != nil  {
        return err
    }

    // Publish on event broker
    return cc.brokerController.Publish("{{$key}}", um)
}
{{end}}
{{end}}

// Listen will let the controller handle subscriptions and will be interrupted
// only when an struct is sent on the interrupt channel
func (cc *ClientController) Listen(irq chan interface{}){
	<-irq
}

{{/* Specific to client */ -}}
{{- range  $key, $value := .Specification.Channels -}}
{{- if and $value.Subscribe (ne $value.Subscribe.Message.CorrelationIDLocation "")}}
// WaitFor{{namify $key}} will wait for a specific message by its correlation ID
//
// The pub function is the publication function that should be used to send the message
// It will be called after subscribing to the channel to avoid race condition, and potentially loose the message
func (cc *ClientController) WaitFor{{namify $key}}(correlationID string, pub func() error, timeout time.Duration) ({{channelToMessageTypeName $value}}, error) {
    // Subscribe to broker channel
    msgs, stop, err := cc.brokerController.Subscribe("{{$key}}")
    if err != nil {
        return {{channelToMessageTypeName $value}}{}, err
    }

    // Close subscriber on leave
    defer func(){ stop <- true } ()

    // Execute publication 
    if err := pub(); err != nil {
        return {{channelToMessageTypeName $value}}{}, err
    }

    // Wait for corresponding response
    for {
        select {
        case um := <-msgs:
            msg, err := new{{channelToMessageTypeName $value}}FromUniversalMessage(um)
            if err != nil {
                log.Printf("an error happened when receiving an event: %s (msg: %+v)\n", err, msg) // TODO: add proper error handling
                continue
            }

            if correlationID == msg.{{referenceToStructAttributePath $value.Subscribe.Message.CorrelationIDLocation}} {
                return msg, nil
            }
        case <-time.After(timeout): // TODO: make it consumable between two call
            return {{channelToMessageTypeName $value}}{}, ErrTimedOut
        }
    }
}
{{- end -}}
{{- end}}
